int n = 10;
mesh Th = square(n,n);
plot(Th, wait=1, cmm="Mesh");
fespace Vh(Th, P1);
Vh uh, vh;
int Nu = Vh.ndof;

/* 1) Normale: funziona */
// macro grad(u) [dx(u), dy(u)] //

/* 2) 1.0+ direttamente nella macro: da error operator + <d>, <10LinearCombI7MGauche4C_F0E>  */
// macro grad(u) [1.0+dx(u), 1.0+dy(u)] //

/* 3) Suggerimento Nicola: da error operator + <d>, <10LinearCombI7MGauche4C_F0E> */
macro grad1(u) (1.0+dx(u)) //
macro grad2(u) (1.0+dy(u)) //
macro grad(u) [grad1(u), grad2(u)] //

func f = 2.0*(y^2 - 1.0)*exp(-x);
problem diffreact(uh,vh) = int2d(Th) ((dx(uh))*vh + (dy(uh))*vh + 3.0 * uh * vh)
                            - int2d(Th) (f * vh)
                            - int2d(Th, 2) (y^2 * vh)
                            - int2d(Th, 3) (vh)
                            - int2d(Th, 4) (-y^2 * vh);
diffreact;
plot(uh, fill=1, value=1, cmm="Velocity solved with problem", wait=1);
