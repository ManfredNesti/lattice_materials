//estensione case1.edp di Nicola Ferro a 3d
load "ff-Ipopt";
load "ffrandom";
load "iovtk";
//msh3 per la mesh in 3d
load "msh3";
//verbosity = 1;

//NON CHIARO A CHE SERVA ANCORA
// Vettore per il salvataggio delle immagini in formato vtk (da usare in Paraview)
int[int] ffordervel = [1];
int ii = 0;

int jj = 0;
int n = 30;
mesh3 Th = cube(n, n, n, [x, y, z]);
plot (Th);


// Spazi funzionali (periodici e non)
//periodic impose periodic bc: vd file txt, i n.sono facce es:faccia 5 e 6 devonon coincidere sul piano x y
fespace Vh1 (Th, P1);
fespace Vhp(Th, P1, periodic = [[1,y,z],[2,y,z],[3,x,z],[4,x,z],[5,x,y],[6,x,y]]);
fespace Xh (Th,[P1, P1, P1]);
//fespace Xhp (Th,[P1, P1, P1]);
fespace Xhp(Th,[P1, P1, P1],  periodic = [[1,y,z],[2,y,z],[3,x,z],[4,x,z],[5,x,y],[6,x,y]]);

fespace Xh0(Th, P0); //  periodic = [[1,y,z],[2,y,z],[3,x,z],[4,x,z],[5,x,y],[6,x,y]]);
Xh0 vol = area;

Vhp v, vH, psi, lz, uz; //vd file tx con ipotesi su interpretazione var
Vh1 m11, m12, m22;
//Vh1 m11n, m12n, m22n;

//NON CHIARO A COSA SERVA
//verbosity = 0.;

//v = abs(sin(2*pi*x*0.25)*sin(2*pi*y*0.5));
//v = 1;
//v = (x<=0.5)*(y>=0.5)*(y<=0.7);
//v = 5*abs((x-0.5)^2 + (y-0.5)^2 + 0.^8);
//plot(v, fill = 1);


srandom(10);
for(int ii = 0; ii < Vhp.ndof; ii++)
	v[][ii] = random()/3e9;

// Definizione variabili
Xhp [u1star11,u2star11,u3star11], [u1star22,u2star22,u3star22], [u1star12,u2star12,u3star12],
    [u1star33,u2star33,u3star33], [u1star13,u2star13,u3star13], [u1star23,u2star23,u3star23],
    [v1,v2,v3], [z1,z2,z3];
Xhp [l1star11,l2star11,l3star11],[l1star22,l2star22,l3star22];

// Spostamenti trial
// test strain field: corrispondono agli epsilon zero base pag11 Sigmund
Xh [u1011,u2011,u3011] = [x, 0, 0];
Xh [u1022,u2022,u3022] = [0, y, 0];
Xh [u1033,u2033,u3033] = [0, 0, z];
Xh [u1012,u2012,u3012] = [y/2, x/2, 0];
Xh [u1013,u2013,u3013] = [z/2, 0, x/2];
Xh [u1023,u2023,u3023] = [0, z/2, y/2];

real [int] lm(1);

// Varibiali ausiliarie
real q = 4.;
real r = 4.;
real s = 4.;
real radius = 1./50^2;
real Omega = int3d(Th)(1.);
real weigth = 0.;

// Coefficients
real E  = 0.91;
real nu = 0.3;
real L = E*nu/((1.+nu)*(1.-2.*nu)); //lamba
real M = E/(2.*(1.+nu)); //mu

real Volume = int3d(Th)(1.);
cout << "Volume = " << Volume << endl; //qua volevo provare a stampare il volume, non ha funzionato ma errore strano .. vd screen

// Targets
real E1122star, E1111, E2222, E1122, E2211, E1212, E3333, E1133, E3311, E1313, E2233, E3322, E2323;
real eta1122 = 1.;

// Volume fraction e valore target
real vf = 0.3; //alpha
E1122star = -1.0; //nu target negativo

macro div(u,v,w)       ( dx(u)+dy(v)+dz(w) )   // eom
macro epsilon(u,v,w)   [ dx(u), dy(v), dz(w), 0.5*(dx(v) + dy(u)), 0.5*(dx(v) + dy(u)),
                         0.5*(dz(u) + dx(w)), 0.5*(dx(w) + dz(u)), 0.5*(dz(v) + dy(w)), 0.5*(dy(w) + dz(v))]                               // eom
macro sigma  (u,v,w)   [ 2*M*dx(u) + L*div(u,v,w), 2*M*dy(v) + L*div(u,v,w), 2*M*dz(w) + L*div(u,v,w),
                         M*(dx(v) + dy(u)),  M*(dx(v) + dy(u)),
                         M*(dz(u) + dx(w)),  M*(dz(u) + dx(w)),
                         M*(dz(v) + dy(w)),  M*(dz(v) + dy(w))] // eom

// Helmholtz filter
problem helmholtz(vH, psi) = int3d(Th)( radius*(dx(vH)*dx(psi) + dy(vH)*dy(psi)) )
                           + int3d(Th)( vH*psi )
                           - int3d(Th)( v *psi );

// Functional = 1/2 * (delta Target)^2
//Functional to be minimized, contains the state equations
func real J(real[int] & v)
{
  Vhp w;
  w[] = v; //densità
  plot(w, fill = 1, value = 1, cmm = "j = "+jj+" ii = "+ii);

  cout << "Solving primal problems..." << endl;

// solving eq (4) FMP : finds the u∗ corresponding to epsi* ~ the Y-periodic fluctuation strain (component by component)
  solve micro11primal([u1star11, u2star11,u3star11], [v1, v2, v3]) =
	int3d(Th)(w^q*sigma(u1star11,u2star11,u3star11)'*epsilon(v1,v2,v3))
  - int3d(Th)(w^r*sigma(u1011,u2011,u3011)'*epsilon(v1,v2,v3));
	//+on(1, u2star11 = 0) + on(2, u1star11 = 0);
  //? specificazione forse sulle condizioni al bordo che implicitamente sono imposte

  solve micro22primal([u1star22, u2star22,u3star22], [v1, v2, v3]) =
	int3d(Th)(w^q*sigma(u1star22,u2star22,u3star22)'*epsilon(v1,v2,v3))
  - int3d(Th)(w^r*sigma(u1022,u2022,u3022)'*epsilon(v1,v2,v3));
	//+on(1, u2star22 = 0) + on(2, u1star22 = 0);

  solve micro33primal([u1star33, u2star33,u3star33], [v1, v2, v3]) =
	int3d(Th)(w^q*sigma(u1star33,u2star33,u3star33)'*epsilon(v1,v2,v3))
  - int3d(Th)(w^r*sigma(u1033,u2033,u3033)'*epsilon(v1,v2,v3));

  solve micro12primal([u1star12, u2star12,u3star12], [v1, v2, v3]) =
	int3d(Th)(w^q*sigma(u1star12,u2star12,u3star12)'*epsilon(v1,v2,v3))
  - int3d(Th)(w^r*sigma(u1012,u2012,u3012)'*epsilon(v1,v2,v3)); //HO CORRETTO SCRIPT FERRO
	//+on(1, u2star12 = 0) + on(2, u1star12 = 0);

  solve micro13primal([u1star13, u2star13,u3star13], [v1, v2, v3]) =
  int3d(Th)(w^q*sigma(u1star13,u2star13,u3star13)'*epsilon(v1,v2,v3))
  - int3d(Th)(w^r*sigma(u1013,u2013,u3013)'*epsilon(v1,v2,v3));

  solve micro23primal([u1star23, u2star23,u3star23], [v1, v2, v3]) =
  int3d(Th)(w^q*sigma(u1star23,u2star23,u3star23)'*epsilon(v1,v2,v3))
  - int3d(Th)(w^r*sigma(u1023,u2023,u3023)'*epsilon(v1,v2,v3));

// stiffness tensor components eq (5) FMP
  E1111 = int3d(Th)(w^s*(sigma(u1011,u2011,u3011)-sigma(u1star11,u2star11,u3star11))'*(epsilon(u1011,u2011,u3011)-epsilon(u1star11,u2star11,u3star11)));
  E1122 = int3d(Th)(w^s*(sigma(u1011,u2011,u3011)-sigma(u1star11,u2star11,u3star11))'*(epsilon(u1022,u2022,u3022)-epsilon(u1star22,u2star22,u3star22)));
  E2211 = int3d(Th)(w^s*(sigma(u1022,u2022,u3022)-sigma(u1star22,u2star22,u3star22))'*(epsilon(u1011,u2011,u3011)-epsilon(u1star11,u2star11,u3star11)));
  E2222 = int3d(Th)(w^s*(sigma(u1022,u2022,u3022)-sigma(u1star22,u2star22,u3star22))'*(epsilon(u1022,u2022,u3022)-epsilon(u1star22,u2star22,u3star22)));
  E1212 = int3d(Th)(w^s*(sigma(u1012,u2012,u3012)-sigma(u1star12,u2star12,u3star12))'*(epsilon(u1012,u2012,u3012)-epsilon(u1star12,u2star12,u3star12)));
  E3333 = int3d(Th)(w^s*(sigma(u1033,u2033,u3033)-sigma(u1star33,u2star33,u3star33))'*(epsilon(u1033,u2033,u3033)-epsilon(u1star33,u2star33,u3star33)));
  E1133 = int3d(Th)(w^s*(sigma(u1011,u2011,u3011)-sigma(u1star11,u2star11,u3star11))'*(epsilon(u1033,u2033,u3033)-epsilon(u1star33,u2star33,u3star33)));
  E3311 = int3d(Th)(w^s*(sigma(u1033,u2033,u3033)-sigma(u1star33,u2star33,u3star33))'*(epsilon(u1011,u2011,u3011)-epsilon(u1star11,u2star11,u3star11)));
  E1313 = int3d(Th)(w^s*(sigma(u1013,u2013,u3013)-sigma(u1star13,u2star13,u3star13))'*(epsilon(u1013,u2013,u3013)-epsilon(u1star13,u2star13,u3star13)));
  E2233 = int3d(Th)(w^s*(sigma(u1022,u2022,u3022)-sigma(u1star22,u2star22,u3star22))'*(epsilon(u1033,u2033,u3033)-epsilon(u1star33,u2star33,u3star33)));
  E3322 = int3d(Th)(w^s*(sigma(u1033,u2033,u3033)-sigma(u1star33,u2star33,u3star33))'*(epsilon(u1022,u2022,u3022)-epsilon(u1star22,u2star22,u3star22)));
  E2323 = int3d(Th)(w^s*(sigma(u1023,u2023,u3023)-sigma(u1star23,u2star23,u3star23))'*(epsilon(u1023,u2023,u3023)-epsilon(u1star23,u2star23,u3star23)));

  cout << "*********************************************" << endl;
  cout << "j = " << jj << endl;
  cout << "Homogenized Poisson's ratio = " << E1122/E1111 << endl;

  cout.fixed << "Matrix E" << endl;
  cout.fixed << E1111 << endl;
  cout.fixed << " " << endl;
  cout.fixed << "             [ " << E1111/E1111 << "   " << E1122/E1111 << "  " << "  0        ]" << endl;
  cout.fixed << "             [ " << E2211/E1111 << "   " << E2222/E1111 << "  " << "  0        ]" << endl;
  cout.fixed << "             [ " << "0   " << " " << "      0           " << E1212/E1111 << " ]" << endl;

  jj = jj + 1;
  return 0.5*eta1122*((E1122/E1111)/(1+E1122/E1111) - E1122star)^2; //J = 1/2 const * (nu_calcolato - nu_star)^2
}

// Gradient of the functional (approccio lagrangiano)
func real[int] gradJ(real[int] & v)
{
  Vhp w;
  w[] = v;
  real [int] dJ(Vhp.ndof);

  real CurlyC = eta1122*(E1122 - E1122star);

  cout << "Solving dual problems..." << endl;

  solve micro11dual([l1star11, l2star11], [v1, v2]) =
		  int2d(Th)(w^q* sigma(l1star11, l2star11)'*epsilon(v1, v2))
		- int2d(Th)(w^s* sigma(u1022,u2022)'*       epsilon(v1, v2)*2*CurlyC)
		+ int2d(Th)(w^s* sigma(u1star22,u2star22)'* epsilon(v1, v2)*2*CurlyC);
		//+on(1, l2star11 = 0) + on(2, l1star11 = 0);

  solve micro12dual([l1star22, l2star22], [v1, v2]) =
		  int2d(Th)(w^q* sigma(l1star22, l2star22)'*epsilon(v1, v2))
		- int2d(Th)(w^s* sigma(u1011,u2011)'*       epsilon(v1, v2)*2*CurlyC)
		+ int2d(Th)(w^s* sigma(u1star11,u2star11)'* epsilon(v1, v2)*2*CurlyC);
		//+on(1, l2star22 = 0) + on(2, l1star22 = 0);

  varf gradient(SS, psi) =
		  int2d(Th)(
					  s*w^(s-1)*psi*
				    ((sigma(u1011, u2011)-sigma(u1star11, u2star11))'*
                     (epsilon(u1022, u2022)-epsilon(u1star22, u2star22)))*
					  CurlyC
					)
		+ int2d(Th)(
					  q*w^(q-1)*psi*
					 (sigma(u1star11, u2star11)'*epsilon(l1star11, l2star11))
					)

		- int2d(Th)(
					  r*w^(r-1)*psi*
					 (sigma(u1011, u2011)'*epsilon(l1star11, l2star11))
					)

		+ int2d(Th)(
					  q*w^(q-1)*psi*
					 (sigma(u1star22, u2star22)'*epsilon(l1star22, l2star22))
					)

		- int2d(Th)(
					  r*w^(r-1)*psi*
					 (sigma(u1022, u2022)'*epsilon(l1star22, l2star22))
					);

  dJ = gradient(0, Vhp);
  return dJ;
}

// Constraint: volume fraction
func real C(real[int] & v)
{
  Vhp w;
  w[] = v;

  real fraction = int3d(Th)(w);

  return fraction;
}

//i constraint sono passati a ipopt come vettore (vd documentazione FreeFem)
func real[int] ipC(real[int] & v)
{
  real[int] cc = [C(v)];
  return cc;
}

// Constraint gradient
func real[int] dC(real[int] & v)
{
  Vhp w;
  w[] = v;

  varf dc(u,uu)   = int2d(Th)(uu);

  real [int] jacC = dc(0,Vhp);
  return jacC;
}

matrix mdC;

func matrix ipGradC(real[int] & v)
{
  real[int,int] dc(1,Vhp.ndof);
  dc(0,:) = dC(v);

  mdC = dc;
  return mdC;
}

// Variabili per ottimizzatore
int[int] gvi(Vhp.ndof), gvj = 0:Vhp.ndof-1;
gvi = 0;

Vhp xlb = 1e-4, xub = 1;    // lower and upper bounds for v

real tolv = 0.;

real[int] clb = [0*vf*Volume], cub = [vf*Volume]; // lower and upper bounds for constraint

real tolmesh = 0.0001;
real stopmesh = tolmesh + 1.;
int ntold = Th.nt;
int maxit = 21;

v = abs(sin(2*pi*x*0.25)*sin(2*pi*y*0.5));
//v = abs(sin(0.5*pi*x)*sin(1*pi*y));

real tau = .00001;
real maxsK;
include "makemetrica.edp";

while(stopmesh > tolmesh && ii < maxit){ //terri:iiinizializzato a 0 a riga 8

	jj = 0;

	// Ottimizzatore
	IPOPT(J, gradJ, ipC, ipGradC, v[],
	  lb  = xlb[], ub  = xub[],
   	  clb = clb  , cub = cub  ,
	  checkindex = 1, structjacc = [gvi,gvj],
      maxiter = 35*(ii<=3) + 10*(ii>3), warmstart = ii,
	  lm = lm, uz = uz[], lz = lz[]
	  //tol=1e-5,
	  //printlevel = 1,
	  //derivativetest="first-order");
      //,maxiter=10);
	  );

	// Attivazione filtraggio Helmholtz
if(ii <=-2){ //terri:?? iterazione <=-2
	helmholtz;
	plot(v,  wait = 1, fill = 1, cmm = "phase field after IPOPT");
	plot(vH, wait = 1, fill = 1, cmm = "filtered phase field");

	v = vH;
	}

	maxsK = 1;
	ntold = Th.nt;

	// Calcolo metrica e adattazione di mesh (periodica)
	makemetrica(tau);
	Th = adaptmesh(Th, metric = [m11[],m12[],m22[]], nbvx = 12000, periodic=[[2,y],[4,y],[1,x],[3,x]]);  //ANISO
	//plot(Th, wait = 1);
	cout << "maxsK = " << maxsK << endl;

	// Attivazione filtraggio Heaviside (terri:pag6 paper PM)
	if((ii >= 5 && ii <= 6) || ii == 19){
		real beta = 10*(ii < 19) + 7*(ii == 19);
		v = 0.5 + tanh(beta*(v-0.5))/(2*tanh(0.5*beta));
	}

	// Proiezione variabili su nuova mesh
	v = v;
	xlb = xlb;
	xub = xub;
	gvi = gvi;
	gvj = 0:Vhp.ndof-1;
	lz = lz;
	uz = uz;
	m11 = m11;
	m12 = m12;
	m22 = m22;

	stopmesh = abs(Th.nt - real(ntold))/ntold;
	ii += 1;
	cout << "Iterazione " << ii << ", Errore mesh = " << stopmesh << endl;

	savevtk("sol_toll"+tau+"_vf"+vf+"_iter"+(ii-1)+".vtk", Th, v, dataname="Density", order=ffordervel);

}

cout << Th.nt << endl;

plot(v,  wait = 1, fill = 1, cmm = "phase field after IPOPT, FINAL");
plot(vH, wait = 1, fill = 1, cmm = "filtered phase field, FINAL");
