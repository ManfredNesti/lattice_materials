//tensile test with our model for non linear regime in 2d
ofstream out("tensile_non_linear2.csv", append); //file per output

// Macro
//Gradient of a vector field (u1, u2)
macro grad11(u1, u2) (dx(u1)) //
macro grad12(u1, u2) (dy(u1)) // grad21 secondo freefem doc ... sec me sbaglia
macro grad21(u1, u2) (dx(u2)) // grad12 secondo freefem doc ... sec me sbaglia
macro grad22(u1, u2) (dy(u2)) //

//Deformation gradient F
macro F11(u1,u2) (1.0 + grad11(u1,u2)) //
macro F12(u1,u2) (0.0 + grad12(u1,u2)) //
macro F21(u1,u2) (0.0 + grad21(u1,u2)) //
macro F22(u1,u2) (1.0 + grad22(u1,u2)) //
// Components Green-Lagrange strain tensor E
macro E11 (u1,u2) 0.5*(grad11(u1,u2)*grad11(u1,u2) + 2.*grad11(u1,u2) + grad21(u1,u2)*grad21(u1,u2)) //
macro E12 (u1,u2) 0.5*(grad11(u1,u2)*grad12(u1,u2) + grad21(u1,u2)*grad22(u1,u2) + grad12(u1,u2) + grad21(u1,u2) - 1.) //
macro E21 (u1,u2) 0.5*(grad11(u1,u2)*grad12(u1,u2) + grad21(u1,u2)*grad22(u1,u2) + grad12(u1,u2) + grad21(u1,u2) - 1.) //
macro E22 (u1,u2) 0.5*(grad12(u1,u2)*grad12(u1,u2) + 2.*grad22(u1,u2) + grad22(u1,u2)*grad22(u1,u2)) //

macro traceE(u1,u2)	(E11(u1,u2) + E22(u1, u2)) // Trace of Green-Lagrange tensor
macro detF(u1,u2) (F11(u1,u2)* F22(u1,u2) - F12(u1,u2)* F21(u1,u2) ) //
//macro detF(u1,u2) (1 + grad11(u1,u2 + grad22(u1,u2) + grad11(u1,u2*grad22(u1,u2) - grad12(u1,u2*grad21(u1,u2)) //J determinant of F

//Right Cauchy-Green deformation tensor C
macro C11(u1,u2) ((grad11(u1,u2)+1.0)^2+grad21(u1,u2)^2 ) //
macro C12(u1,u2) ((grad11(u1,u2)+1.0)*grad12(u1,u2) + grad21(u1,u2)*(grad22(u1,u2) + 1.0)) //
macro C21(u1,u2) ((grad11(u1,u2)+1.0)*grad12(u1,u2) + grad21(u1,u2)*(grad22(u1,u2) + 1.0)) //
macro C22(u1,u2) ((grad22(u1,u2)+1.0)^2+grad12(u1,u2)^2 ) //

macro detC(u1,u2) ((2*E11(u1,u2)+1)*(2*E22(u1,u2)+1) - 4 * E12(u1,u2) * E21(u1,u2)) // determinantof C
//Inverse of C: C^-1 (simmetryc)
macro invC11(u1,u2) (1/detC(u1,u2) * (2*E22(u1,u2)+1)) //
macro invC12(u1,u2) (1/detC(u1,u2) * (-2*E12(u1,u2))) //
macro invC21(u1,u2) (1/detC(u1,u2) * (-2*E21(u1,u2))) //
macro invC22(u1,u2) (1/detC(u1,u2) * (2*E11(u1,u2)+1)) //

// Second Piola-Kirchhoff stress tensor for Phi4 Sij forse non serve ...

// Dijkl = - d(Cij^-1)/dEkl !!! verificata abbastanza ... anche il meno
macro D1111(u1,u2) (invC11(u1,u2)*invC11(u1,u2) * 2 ) //
macro D1211(u1,u2) (invC11(u1,u2)*invC21(u1,u2) * 2 ) // = D1121, D1112, D2111 for symmetry of C,invC and E
macro D1121(u1,u2) (invC11(u1,u2)*invC12(u1,u2) * 2 ) //
macro D1112(u1,u2) (invC11(u1,u2)*invC12(u1,u2) * 2 ) //
macro D2111(u1,u2) (invC11(u1,u2)*invC21(u1,u2) * 2 ) //
macro D1122(u1,u2) (invC12(u1,u2)*invC12(u1,u2) * 2 ) // = D2211
macro D2211(u1,u2) (invC21(u1,u2)*invC21(u1,u2) * 2 ) //
macro D1212(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) // = D2121, D1221, D2112
macro D2121(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D1221(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D2112(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D2122(u1,u2) (invC22(u1,u2)*invC12(u1,u2) * 2 ) // = D2212, D2221, D1222
macro D2212(u1,u2) (invC22(u1,u2)*invC21(u1,u2) * 2 ) //
macro D2221(u1,u2) (invC22(u1,u2)*invC21(u1,u2) * 2 ) //
macro D2222(u1,u2) (invC22(u1,u2)*invC22(u1,u2) * 2 ) //

//dEij(u1,u2)/du * lambda (l'ho corretto: CI ERAVAMO PERSI UN *0.5 PER STRADA?)
macro gradE11 (u1,u2,l1,l2) (grad11(u1,u2)*dx(l1) + grad21(u1,u2)*dx(l2) + dx(l1)) //
macro gradE12 (u1,u2,l1,l2) (0.5*(grad11(u1,u2)*dy(l1) + grad21(u1,u2)*dy(l2) + grad12(u1,u2)*dx(l1) + grad22(u1,u2)*dx(l2) + dy(l1) + dx(l2))) //
macro gradE21 (u1,u2,l1,l2) (0.5*(grad11(u1,u2)*dy(l1) + grad21(u1,u2)*dy(l2) + grad12(u1,u2)*dx(l1) + grad22(u1,u2)*dx(l2) + dy(l1) + dx(l2))) //
macro gradE22 (u1,u2,l1,l2) (grad12(u1,u2)*dy(l1) + grad22(u1,u2)*dy(l2) + dy(l2)) //

//d^2 Eij(u1,u2)/du^2*lambda * [phi1,phi2] (this is the test function)
macro grad2E11 (phi1,phi2,l1,l2) (gradE11(phi1,phi2,l1,l2)) //
macro grad2E12 (phi1,phi2,l1,l2) (gradE12(phi1,phi2,l1,l2)) //
macro grad2E21 (phi1,phi2,l1,l2) (gradE21(phi1,phi2,l1,l2)) //
macro grad2E22 (phi1,phi2,l1,l2) (gradE22(phi1,phi2,l1,l2)) //

// Parameters
real q = 4.; //power for pensalty method

real  vold;
real Pa = 0; //no forces

real nu = 0.3;
real E = 1.;
real L = E*nu/(1-nu^2); //E*nu/(1+nu)/(1-2*nu); HO TENUTO QUELLO SBAGLIATO
real M = E/(2*(1+nu));
// real mu = 0.012e5; //kg/cm^2
// real lambda = 0.4e5; //kg/cm^2
real coef = 0.1;
real  u = 1.,  v = -0.1; //traction bc
// Mesh & Fespace

mesh   Th = square(20,20);
//density space
fespace Xh(Th,P1);
fespace Xhp(Th, P1, periodic = [[2,y],[4,y],[1,x],[3,x]]);
Xhp rho;
rho = 1;

//displacement space
fespace Vh(Th, [P1, P1]);
Vh [u1,u2],[psi1,psi2], [varu1,varu2], [err1,err2];

// Problem: try fix point method
problem primal_linearized([varu1,varu2], [psi1, psi2]) =
  int2d(Th) (L*detF(u1,u2)*(detF(u1,u2)-1.0) * (C11(u1,u2) * gradE11(varu1,varu2,psi1,psi2)
                                               + C12(u1,u2) * gradE12(varu1,varu2,psi1,psi2)
                                               + C21(u1,u2) * gradE21(varu1,varu2,psi1,psi2)
                                               + C22(u1,u2) * gradE22(varu1,varu2,psi1,psi2))
             + 2.0 * M * (E11(u1,u2) * gradE11(varu1,varu2,psi1,psi2) + E12(u1,u2) * gradE12(varu1,varu2,psi1,psi2)
                        + E21(u1,u2) * gradE21(varu1,varu2,psi1,psi2) + E22(u1,u2) * gradE22(varu1,varu2,psi1,psi2)))

  + on(2,varu1=u) //dirichlet
  + on(1,varu2=0) // symmetric bc
  + on(4,varu1=0) // symmetric bc
  ;

//Initialization:
[varu1, varu2] = [0., 0.];
[u1, u2] = [0., 0.];
real tol = 1.e-4;
real res = 2. * tol;
int loopcount = 0;
int loopmax = 45;
real err = 0.;

func real error()
{
  // store increments in err variables
  err1[] = varu1[];
  err1[] -= u1[];

  // compute increment norms
  real erru = int2d(Th)(dx(err1)^2 + dy(err1)^2 +
                        dx(err2)^2 + dy(err2)^2 +
                        err1^2 + err2^2);
  real normu = int2d(Th)(dx(u1)^2 + dy(u1)^2 +
                         dx(u2)^2 + dy(u2)^2 +
                         u1^2 + u2^2);
  // return error estimate (stopping criterion)
  return sqrt(erru / normu);
}
// Fixed point  method
while (loopcount <= loopmax && res >= tol){
    loopcount ++;
    cout << "Loop " << loopcount << endl;

    // Solve
    primal_linearized;
    // update err for the stopping criterion
    err = error();

    // Update
    u1 = varu1;
    u2 = varu2;

    cout << " L^2 residual = " << res << endl;

    // Plot
    plot([u1,u2], cmm="displacement");
}

// Plot
plot([u1, u2], wait=true);
plot(u1,fill=1,dim=3,wait = 1, cmm="u1");
plot(u2,fill=1,dim=3,wait = 1, cmm="u2");

// Movemesh
real minarea = checkmovemesh(Th, [x+coef*u1, y+coef*u2]);
if (minarea > 0) { //movemesh will be ok
  mesh th1 = movemesh(Th, [x+coef*u1, y+coef*u2]);
  plot(th1, wait=true);
  plot(Th, th1, wait=true);
}

cout << " --- ERROR --- Min area = " << minarea << endl;

// Plot

//estimated nu
real d1 = int1d(Th,2)(u1) - int1d(Th,4)(u1);
real d2 = int1d(Th,3)(u2) - int1d(Th,1)(u2);;
cout << "d1 = " << d1 << endl;
cout << "d2 = " << d2 << endl;
real nu12 = -d2/d1;
cout << "estimated nu = " << nu12 << endl;

//output
out << nu12 << ",";
out << endl;
