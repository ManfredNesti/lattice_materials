int t = time();
exec("mkdir results_tensile_nu");
exec("mkdir results_tensile_nu/"+t);
ofstream out("results_tensile_nu/"+t+"/tensile_nu.csv", append); //file per output epsilon11,epsilon12,epsilon22,sigma12,nu12(,nu21 non ha senso ...)
mesh   Th = square(20,20); // reference domain to show mesh deformation
fespace Vh(Th,[P1,P1]);
Vh [u1,u2], [v1,v2], [lam1,lam2], [mu1,mu2], [u1old,u2old];
fespace Xh(Th,P1);
fespace Xhp(Th, P1,       periodic = [[2,y],[4,y],[1,x],[3,x]]); //fespace for density (need to be periodic?)
Xhp rho;
real q = 4.; //power for pensalty method
rho = 1; ///set density equal to 1
real  u = 0.05,  v = -0.1;
real  vold;
Xh   ax = 1, ay = 0;
Xh   bx = 0, by = 1;
Xh    E = 0.0072;//+sin(5*pi*x)^2;
real nu = 0.3;
plot(E,fill=1,dim=3,wait = 1, cmm="E");
Xh lambda = E*nu/(1-nu^2); //E*nu/(1+nu)/(1-2*nu);
Xh     mu = E/(2*(1+nu));
macro eps11(u,v) ( dx(u)) //
macro eps22(u,v) ( dy(v)) //
macro eps12(u,v) ((dx(v)+dy(u))/2) //
macro trace(u,v) ( dx(u)+dy(v)) //
macro sig11(u,v) (2*mu*eps11(u,v) + lambda*trace(u,v)) //
macro sig22(u,v) (2*mu*eps22(u,v) + lambda*trace(u,v)) //
macro sig12(u,v) (2*mu*eps12(u,v)) //
real tol = 1e-4, err = 1+tol, gamma = 1e6, coef = 0.1;
problem tensile([u1,u2],[v1,v2]) = int2d(Th)(rho^q*(sig11(u1,u2)*eps11(v1,v2)
                                        + sig22(u1,u2)*eps22(v1,v2)
                                     +  2*sig12(u1,u2)*eps12(v1,v2)))
                                 + on(2,u1=u)
                                 + on(1,u2=0) //symmetric bc lato sotto
                                 + on(4,u1=0); // symmetric bc lato sinistro
                                 //Neumann hom. lato sopra

[u1old, u2old] = [1,1];
vold = v;
while(err > tol)
{
  tensile;
  v = v + 1e-6*int1d(Th,3)(u2-convect([bx,by],-1,u2)-v); //dubbi su cosa sia v qua (c'entra forse con coef?)
  cout << "v = " << v << endl;
  err = sqrt(int2d(Th)((u1-u1old)^2 + (u2-u2old)^2)) + 0*abs(v - vold);
  cout << "err = " << err << endl;
  [u1old,u2old] = [u1,u2];
  vold = v;
}
real d1 = int1d(Th,2)(rho*u1) - int1d(Th,4)(rho*u1);
real d2 = int1d(Th,3)(rho*u2) - int1d(Th,1)(rho*u2);;
cout << "d1 = " << d1 << endl;
cout << "d2 = " << d2 << endl;
real nu12 = -d2/d1;
cout << "estimated nu = " << nu12 << endl;
plot(u1,fill=1,dim=3,wait = 1, cmm="u1");
plot(u2,fill=1,dim=3,wait = 1, cmm="u2");

mesh Thd = movemesh(Th,[x+coef*u1,y+coef*u2]);
plot(Th,Thd,wait = 1);
plot(Thd, wait = 1);
for (int i=0; i<10; i++)
{
  real s = i/10.;
  cout << u1(1,s)-u1(0,s) << " " << u2(1,s)-u2(0,s) << " " << u1(s,1)-u1(s,0) << " " << u2(s,1)-u2(s,0) <<endl;
}

//epsilon11,epsilon12,epsilon22,sigma11,sigma12,sigma22,nu12
out << int2d(Th) (rho*eps11(u1,u2)) << ",";
out << int2d(Th) (rho*eps12(u1,u2)) << ",";
out << int2d(Th) (rho*eps22(u1,u2)) << ",";
out << int2d(Th) (rho*sig11(u1,u2)) << ",";
out << int2d(Th) (rho*sig12(u1,u2)) << ",";
out << int2d(Th) (rho*sig22(u1,u2)) << ",";
out << nu12 << ",";
//  out << nu21 << ",";
out << endl;
