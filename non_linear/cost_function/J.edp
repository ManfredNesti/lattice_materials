// ***************************************************************************
// Functional J = 1/2 * (delta Target)^2
// ***************************************************************************
func real J(real[int] & v)
{
  Xhp w;
  w[] = v;
  plot(w, fill = 1, value = 1, cmm = "j = "+jj+" ii = "+ii);

  // Sigmund filtering
  if(sigIN){
    plot(w, fill = 1, value = 1, cmm = "j = "+jj+" ii = "+ii);
    eta = (ii <= 2)*0.4 + (ii > 2 && ii <= 4)*0.5 + (ii > 4)*0.55;
  	//beta = 2. * beta;
    // beta = betamax - (betamax - betamin) * exp(- jj / 2); //se vogliamo incrementare pi√π "soft"
		wSig = (1-xlb) * (tanh(beta * eta) + tanh(beta * (w - xlb - eta)))
                   / (tanh(beta * eta) + tanh(beta * (1 - xlb - eta))) + xlb;
    plot(w, fill = 1, value = 1, cmm = " Density post-Sigmund j = "+jj+" ii = "+ii);
		w = wSig;
  }

  cout << "*********************************************" << endl;
  cout << "PRIMAL PROBLEM ..." << endl;
  include "cost_function/primal.edp";
  include "cost_function/newton.edp";

	real d2 = int1d(Th,3)(u2);
	nu12 = - d2 / d1; // estimated nu

  cout << "POISSON'S RATIO = " << nu12 << endl;
  cout << "*********************************************" << endl;

	return 0.5 * (nu12 - nutarget)^2;
}
