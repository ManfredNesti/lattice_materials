load "ff-Ipopt";
load "ffrandom";
load "iovtk";
//verbosity = 1;

// Vettore per il salvataggio delle immagini in formato vtk (da usare in Paraview)
int[int] ffordervel = [1];
int ii = 0;

int jj = 0;
int n = 30;
mesh Th = square(n, n, [x, y]);

// Spazi funzionali (periodici e non)
fespace Vh1 (Th, P1);
fespace Vhp(Th, P1,       periodic = [[2,y],[4,y],[1,x],[3,x]]);
fespace Xh (Th,[P1, P1]);
//fespace Xhp (Th,[P1, P1]);
fespace Xhp(Th,[P1, P1],  periodic = [[2,y],[4,y],[1,x],[3,x]]);

fespace Xh0(Th, P0); //  periodic = [[2,y],[4,y],[1,x],[3,x]]);
Xh0 vol = area;

Vhp v, vH, psi, lz, uz;
Vh1 m11, m12, m22;
//Vh1 m11n, m12n, m22n;

//verbosity = 0.;

//v = abs(sin(2*pi*x*0.25)*sin(2*pi*y*0.5));
//v = 1;
//v = (x<=0.5)*(y>=0.5)*(y<=0.7);
//v = 5*abs((x-0.5)^2 + (y-0.5)^2 + 0.^8);
//plot(v, fill = 1);


srandom(10);
for(int ii = 0; ii < Vhp.ndof; ii++)
	v[][ii] = random()/3e9;

// Definizione variabili
Xhp [u1star11,u2star11], [u1star22,u2star22], [u1star12,u2star12], [u1star21,u2star21],
		[v1,v2], [z1,z2];
Xhp [l1star11,l2star11], [l1star22,l2star22], [l1star12,l2star12], [l1star21,l2star21];

// Spostamenti trial
// Xh [u1011,u2011] = [x, 0];
// Xh [u1022,u2022] = [0, y];
// Xh [u1012,u2012] = [y, 0];

real [int] lm(1);

// Varibiali ausiliarie
real q = 4.;
real r = 4.;
real s = 4.;
real radius = 1./50^2;
real Omega = int2d(Th)(1.);
real weigth = 0.;

// Coefficients
real E  = 0.91;
real nu = 0.3;
real L = E * nu / ((1. - nu) * (1. - 2. * nu));
real M = E / (2. * (1. + nu));

real Volume = int2d(Th)(1.);

// Targets
// real E1122star, E1111, E2222, E1122, E2211, E1212;
// real eta1122 = 1.;

// Volume fraction e valore target
real vf = 0.3;

macro div(u,v)       (dx(u) + dy(v))                                                                          // eom
// macro epsilon(u,v)   [ dx(u), dy(v), 0.5*(dx(v) + dy(u)), 0.5*(dx(v) + dy(u)) ]                               // eom
// macro sigma  (u,v)   [ 2*M*dx(u) + L*div(u,v), 2*M*dy(v) + L*div(u,v), M*(dx(v) + dy(u)),  M*(dx(v) + dy(u))] // eom
macro F(u,v)	[dx(u), dy(v), dx(v), dy(v)] // Deformation gradient

// Components Green-Lagrange tensor
macro E_11 (u,v) 0.5*(dx(u)*dx(u) + dx(v)*dx(v) - 1)
macro E_12 (u,v) 0.5*(dx(u)*dy(u) + dx(v)*dy(v))
macro E_21 (u,v) 0.5*(dx(u)*dy(u) + dx(v)*dy(v))
macro E_22 (u,v) 0.5*(dy(u)*dy(u) + dy(v)*dy(v) - 1)

macro trace_E(u,v)	0.5*(dx(u)*dx(u) + dx(v)*dx(v) - 1) + 0.5*(dy(u)*dy(u) + dy(v)*dy(v) - 1) // Trace of Green-Lagrange tensor

// Second Piola-Kirchhoff stress tensor
macro S(u,v)	[L*trace_E(u,v) + 2*M*0.5*(dx(u)*dx(u) + dx(v)*dx(v) - 1),
							 2*M*0.5*(dx(u)*dy(u) + dx(v)*dy(v)),
							 2*M*0.5*(dx(u)*dy(u) + dx(v)*dy(v)),
							 L*trace_E(u,v) + 2*M*0.5*(dy(u)*dy(u) + dy(v)*dy(v) - 1)]

macro grad_E_11 (u1,u2, l1, l2) 2.*dx(u1)*dx(l1) + 2.*dx(u2)*dx(l2) + 2.*dx(l1)
macro grad_E_12 (u1,u2, l1, l2) dx(u1)*dy(l1) + dy(u1)*dx(l1) + dx(u2)*dy(l2) + dy(u2)*dx(l2) + dy(l1) + dx(l2)
macro grad_E_21 (u1,u2, l1, l2) dx(u1)*dy(l1) + dy(u1)*dx(l1) + dx(u2)*dy(l2) + dy(u2)*dx(l2) + dy(l1) + dx(l2)
macro grad_E_22 (u1,u2, l1, l2) 2.*dy(u1)*dy(l1) + 2.*dy(u2)*dy(l2) + 2.*dy(l2)

// Helmholtz filter
problem helmholtz(vH, psi) = int2d(Th)( radius*(dx(vH)*dx(psi) + dy(vH)*dy(psi)) )
                           + int2d(Th)( vH*psi )
                           - int2d(Th)( v *psi );

// Functional = 1/2 * (delta Target)^2
func real J(real[int] & v)
{
  Vhp w;
  w[] = v;
  plot(w, fill = 1, value = 1, cmm = "j = "+jj+" ii = "+ii);

  cout << "Solving primal problems..." << endl;

  solve micro11primal([u1star11, u2star11], [v1, v2]) =
	int2d(Th)(w^q * L * trace_E(l1star11, l2star11) *
						0.5 * grad_E_11(u1star11, u2star11, v1, v2) +
						w^q * 2. * M * E_11(l1star11, l2star11) * grad_E_11(u1star11, u2star11, v1, v2));
	//+on(1, u2star11 = 0) + on(2, u1star11 = 0);

	solve micro22primal([u1star22, u2star22], [v1, v2]) =
	int2d(Th)(w^q * L * trace_E(l1star22, l2star22) *
						0.5 * grad_E_11(u1star11, u2star11, v1, v2) +
						w^q * 2. * M * E_22(l1star22, l2star22) * grad_E_22(u1star22, u2star22, v1, v2));
	//+on(1, u2star22 = 0) + on(2, u1star22 = 0);

	solve micro12primal([u1star12, u2star12], [v1, v2]) =
	int2d(Th)(w^q * 2. * M * E_12(l1star12, l2star12) * grad_E_12(u1star12, u2star12, v1, v2));
	//+on(1, u2star12 = 0) + on(2, u1star12 = 0);

	solve micro21primal([u1star21, u2star21], [v1, v2]) =
	int2d(Th)(w^q * 2. * M * E_21(l1star21, l2star21) * grad_E_21(u1star21, u2star21, v1, v2));
	//+on(1, u2star21 = 0) + on(2, u1star21 = 0);

	/*
  E1111 = int2d(Th)(w^s*(sigma(u1011,u2011)-sigma(u1star11,u2star11))'*(epsilon(u1011,u2011)-epsilon(u1star11,u2star11)));
  E1122 = int2d(Th)(w^s*(sigma(u1011,u2011)-sigma(u1star11,u2star11))'*(epsilon(u1022,u2022)-epsilon(u1star22,u2star22)));
  E2211 = int2d(Th)(w^s*(sigma(u1022,u2022)-sigma(u1star22,u2star22))'*(epsilon(u1011,u2011)-epsilon(u1star11,u2star11)));
  E2222 = int2d(Th)(w^s*(sigma(u1022,u2022)-sigma(u1star22,u2star22))'*(epsilon(u1022,u2022)-epsilon(u1star22,u2star22)));
  E1212 = int2d(Th)(w^s*(sigma(u1012,u2012)-sigma(u1star12,u2star12))'*(epsilon(u1012,u2012)-epsilon(u1star12,u2star12)));

  cout << "*********************************************" << endl;
  cout << "j = " << jj << endl;
  cout << "Homogenized Poisson's ratio = " << E1122/E1111 << endl;

  cout.fixed << "Matrix E" << endl;
  cout.fixed << E1111 << endl;
  cout.fixed << " " << endl;
  cout.fixed << "             [ " << E1111/E1111 << "   " << E1122/E1111 << "  " << "  0        ]" << endl;
  cout.fixed << "             [ " << E2211/E1111 << "   " << E2222/E1111 << "  " << "  0        ]" << endl;
  cout.fixed << "             [ " << "0   " << " " << "      0           " << E1212/E1111 << " ]" << endl;
	*/

  jj = jj + 1;
  return 1;
}

// Gradient of the functional (approccio lagrangiano)
func real[int] gradJ(real[int] & v)
{
  Vhp w;
  w[] = v;
  real [int] dJ(Vhp.ndof);

  real CurlyC = eta1122*(E1122 - E1122star);

  cout << "Solving dual problems..." << endl;

	solve micro11dual([l1star11, l2star11], [z1, z2]) =
	int2d(Th)(w^q * L * trace_E(u1star11, u2star11) *
						0.5 * grad_E_11(l1star11, l2star11, z1, z2) +
						w^q * 2. * M * E_11(u1star11, u2star11) * grad_E_11(l1star11, l2star11, z1, z2));
	//+on(1, u2star11 = 0) + on(2, u1star11 = 0);

	solve micro22dual([l1star22, l2star22], [z1, z2]) =
	int2d(Th)(w^q * L * trace_E(u1star22, u2star22) *
						0.5 * grad_E_11(l1star11, l2star11, z1, z2) +
						w^q * 2. * M * E_22(u1star22, u2star22) * grad_E_22(l1star22, l2star22, z1, z2));
	//+on(1, u2star22 = 0) + on(2, u1star22 = 0);

	solve micro12dual([l1star12, l2star12], [z1, z2]) =
	int2d(Th)(w^q * 2. * M * E_12(u1star12, u2star12) * grad_E_12(l1star12, l2star12, z1, z2));
	//+on(1, u2star12 = 0) + on(2, u1star12 = 0);

	solve micro21dual([l1star21, l2star21], [z1, z2]) =
	int2d(Th)(w^q * 2. * M * E_21(u1star21, u2star21) * grad_E_21(l1star21, l2star21, z1, z2));
	//+on(1, u2star21 = 0) + on(2, u1star21 = 0);

	/*
  varf gradient(SS, psi) =
		  int2d(Th)(
					  s*w^(s-1)*psi*
				    ((sigma(u1011, u2011)-sigma(u1star11, u2star11))'*
                     (epsilon(u1022, u2022)-epsilon(u1star22, u2star22)))*
					  CurlyC
					)
		+ int2d(Th)(
					  q*w^(q-1)*psi*
					 (sigma(u1star11, u2star11)'*epsilon(l1star11, l2star11))
					)

		- int2d(Th)(
					  r*w^(r-1)*psi*
					 (sigma(u1011, u2011)'*epsilon(l1star11, l2star11))
					)

		+ int2d(Th)(
					  q*w^(q-1)*psi*
					 (sigma(u1star22, u2star22)'*epsilon(l1star22, l2star22))
					)

		- int2d(Th)(
					  r*w^(r-1)*psi*
					 (sigma(u1022, u2022)'*epsilon(l1star22, l2star22))
					);

	*/

  // dJ = gradient(0, Vhp);
  return 1; //dJ;
}

// Constraint: volume fraction
func real C(real[int] & v)
{
  Vhp w;
  w[] = v;

  real fraction = int2d(Th)(w);

  return fraction;
}

func real[int] ipC(real[int] & v)
{
  real[int] cc = [C(v)];
  return cc;
}

// Constraint gradient
func real[int] dC(real[int] & v)
{
  Vhp w;
  w[] = v;

  varf dc(u,uu)   = int2d(Th)(uu);

  real [int] jacC = dc(0,Vhp);
  return jacC;
}

matrix mdC;

func matrix ipGradC(real[int] & v)
{
  real[int,int] dc(1,Vhp.ndof);
  dc(0,:) = dC(v);

  mdC = dc;
  return mdC;
}

// Variabili per ottimizzatore
int[int] gvi(Vhp.ndof), gvj = 0:Vhp.ndof-1;
gvi = 0;

Vhp xlb = 1e-4, xub = 1;    // lower and upper bounds for v

real tolv = 0.;

real[int] clb = [0*vf*Volume], cub = [vf*Volume]; // lower and upper bounds for constraint

real tolmesh = 0.0001;
real stopmesh = tolmesh + 1.;
int ntold = Th.nt;
int maxit = 21;

v = abs(sin(2*pi*x*0.25)*sin(2*pi*y*0.5));
//v = abs(sin(0.5*pi*x)*sin(1*pi*y));

real tau = .00001;
real maxsK;
include "makemetrica.edp";

while(stopmesh > tolmesh && ii < maxit){

	jj = 0;

	// Ottimizzatore
	IPOPT(J, gradJ, ipC, ipGradC, v[],
	  lb  = xlb[], ub  = xub[],
   	  clb = clb  , cub = cub  ,
	  checkindex = 1, structjacc = [gvi,gvj],
      maxiter = 35*(ii<=3) + 10*(ii>3), warmstart = ii,
	  lm = lm, uz = uz[], lz = lz[]
	  //tol=1e-5,
	  //printlevel = 1,
	  //derivativetest="first-order");
      //,maxiter=10);
	  );

	// Attivazione filtraggio Helmholtz
	if(ii <=-2){
	helmholtz;
	plot(v,  wait = 1, fill = 1, cmm = "phase field after IPOPT");
	plot(vH, wait = 1, fill = 1, cmm = "filtered phase field");

	v = vH;
	}

	maxsK = 1;
	ntold = Th.nt;

	// Calcolo metrica e adattazione di mesh (periodica)
	makemetrica(tau);
	Th = adaptmesh(Th, metric = [m11[],m12[],m22[]], nbvx = 12000, periodic=[[2,y],[4,y],[1,x],[3,x]]);  //ANISO
	//plot(Th, wait = 1);
	cout << "maxsK = " << maxsK << endl;

	// Attivazione filtraggio Heaviside
	if((ii >= 5 && ii <= 6) || ii == 19){
		real beta = 10*(ii < 19) + 7*(ii == 19);
		v = 0.5 + tanh(beta*(v-0.5))/(2*tanh(0.5*beta));
	}

	// Proiezione variabili su nuova mesh
	v = v;
	xlb = xlb;
	xub = xub;
	gvi = gvi;
	gvj = 0:Vhp.ndof-1;
	lz = lz;
	uz = uz;
	m11 = m11;
	m12 = m12;
	m22 = m22;

	stopmesh = abs(Th.nt - real(ntold))/ntold;
	ii += 1;
	cout << "Iterazione " << ii << ", Errore mesh = " << stopmesh << endl;

	savevtk("sol_toll"+tau+"_vf"+vf+"_iter"+(ii-1)+".vtk", Th, v, dataname="Density", order=ffordervel);

}

cout << Th.nt << endl;

plot(v,  wait = 1, fill = 1, cmm = "phase field after IPOPT, FINAL");
plot(vH, wait = 1, fill = 1, cmm = "filtered phase field, FINAL");
