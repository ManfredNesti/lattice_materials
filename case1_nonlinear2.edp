load "ff-Ipopt";
load "ffrandom";
load "iovtk";
//verbosity = 1;

// Vettore per il salvataggio delle immagini in formato vtk (da usare in Paraview)
int[int] ffordervel = [1];
int ii = 0;

int jj = 0;
int n = 30;
mesh Th = square(n, n, [x, y]);

// Spazi funzionali (periodici e non) (BC???)
fespace Vh1 (Th, P1);
fespace Vhp(Th, P1 /*       periodic = [[2,y],[4,y],[1,x],[3,x]]*/);
fespace Xh (Th,[P1, P1]);
//fespace Xhp (Th,[P1, P1]);
fespace Xhp(Th,[P1, P1] /*,  periodic = [[2,y],[4,y],[1,x],[3,x]]*/);

fespace Xh0(Th, P0); //  periodic = [[2,y],[4,y],[1,x],[3,x]]);
Xh0 vol = area;

Vhp v, vH, psi, lz, uz;
Vh1 m11, m12, m22;
//Vh1 m11n, m12n, m22n;

//verbosity = 0.;

//v = abs(sin(2*pi*x*0.25)*sin(2*pi*y*0.5));
//v = 1;
//v = (x<=0.5)*(y>=0.5)*(y<=0.7);
//v = 5*abs((x-0.5)^2 + (y-0.5)^2 + 0.^8);
//plot(v, fill = 1);


srandom(10);
for(int ii = 0; ii < Vhp.ndof; ii++)
	v[][ii] = random()/3e9;

// Definizione variabili (eventualmente da cambiare lo spazio se cambia la trattazione delle BC)
Xhp [u1, u2], [psi1, psi2], [l1, l2], [phi1, phi2];


real [int] lm(1);

// Varibiali ausiliarie
real q = 4.;
real r = 4.;
real s = 4.;
real radius = 1./50^2;
real Omega = int2d(Th)(1.);
real weigth = 0.;

// Coefficients
real E  = 0.91;
real nu = 0.3;
real L = E * nu / ((1. - nu) * (1. - 2. * nu)); //lambdaL
real M = E / (2. * (1. + nu)); //muL

real Volume = int2d(Th)(1.);

// Volume fraction e valore target
real vf = 0.3;

//Macro definitions
//Deformation gradient F
macro F11(u1,u2)	(dx(u1)+1.0) //
macro F12(u1,u2) (dy(u1)) //
macro F21(u1,u2) (dx(u2)) //
macro F22(u1,u2) (dy(u2) + 1.0) //
// Components Green-Lagrange strain tensor E
macro E11 (u1,u2) 0.5*(dx(u1)*dx(u1) + 2.*dx(u1) + dx(u2)*dx(u2)) //
macro E12 (u1,u2) 0.5*(dx(u1)*dy(u1) + dx(u2)*dy(u2) + dy(u1) + dx(u2) - 1.) //
macro E21 (u1,u2) 0.5*(dx(u1)*dy(u1) + dx(u2)*dy(u2) + dy(u1) + dx(u2) - 1.) //
macro E22 (u1,u2) 0.5*(dy(u1)*dy(u1) + 2.*dy(u2) + dy(u2)*dy(u2)) //

macro traceE(u1,u2)	(E11(u1,u2) + E22(u1, u2)) // Trace of Green-Lagrange tensor
//macro detF(u1,u2) (F(u1,u2)'*[1,0,0,0] * F(u1,u2)'*[0,0,0,1] + F(u1,u2)'*[0,1,0,0] * F(u1,u2)'*[0,0,1,0]   ) not sure if ok, if works ...
macro detF(u1,u2) (1. + dx(u1) + dy(u2) + dx(u1)*dy(u2) - dy(u1)*dx(u2)) //J determinant of F

//Right Cauchy-Green deformation tensor C
macro C11(u1,u2) ((dx(u1)+1.0)^2+dx(u2)^2 ) //
macro C12(u1,u2) ((dx(u1)+1.0)*dy(u1) + dx(u2)*(dy(u2) + 1.0)) //
macro C21(u1,u2) ((dx(u1)+1.0)*dy(u1) + dx(u2)*(dy(u2) + 1.0)) //
macro C22(u1,u2) ((dy(u2)+1.0)^2+dy(u1)^2 ) //

macro detC(u1,u2) ((2*E11(u1,u2)+1)*(2*E22(u1,u2)+1) - 4 * E12(u1,u2) * E21(u1,u2)) // determinantof C
//Inverse of C: C^-1 (simmetryc)
macro invC11(u1,u2) (1/detC(u1,u2) * (2*E22(u1,u2)+1)) //
macro invC12(u1,u2) (1/detC(u1,u2) * (-2*E12(u1,u2))) //
macro invC21(u1,u2) (1/detC(u1,u2) * (-2*E21(u1,u2))) //
macro invC22(u1,u2) (1/detC(u1,u2) * (2*E11(u1,u2)+1)) //

// Second Piola-Kirchhoff stress tensor for Phi4 Sij forse non serve ...

// Dijkl = - d(Cij^-1)/dEkl !!! verificata abbastanza ... anche il meno
macro D1111(u1,u2) (invC11(u1,u2)*invC11(u1,u2) * 2 ) //
macro D1211(u1,u2) (invC11(u1,u2)*invC21(u1,u2) * 2 ) // = D1121, D1112, D2111 for symmetry of C,invC and E
macro D1121(u1,u2) (invC11(u1,u2)*invC12(u1,u2) * 2 ) //
macro D1112(u1,u2) (invC11(u1,u2)*invC12(u1,u2) * 2 ) //
macro D2111(u1,u2) (invC11(u1,u2)*invC21(u1,u2) * 2 ) //
macro D1122(u1,u2) (invC12(u1,u2)*invC12(u1,u2) * 2 ) // = D2211
macro D2211(u1,u2) (invC21(u1,u2)*invC21(u1,u2) * 2 ) //
macro D1212(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) // = D2121, D1221, D2112
macro D2121(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D1221(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D2112(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D2122(u1,u2) (invC22(u1,u2)*invC12(u1,u2) * 2 ) // = D2212, D2221, D1222
macro D2212(u1,u2) (invC22(u1,u2)*invC21(u1,u2) * 2 ) //
macro D2221(u1,u2) (invC22(u1,u2)*invC21(u1,u2) * 2 ) //
macro D2222(u1,u2) (invC22(u1,u2)*invC22(u1,u2) * 2 ) //

//dEij(u1,u2)/du * lambda (l'ho corretto: CI ERAVAMO PERSI UN *0.5 PER STRADA?)
macro gradE11 (u1,u2,l1,l2) (dx(u1)*dx(l1) + dx(u2)*dx(l2) + dx(l1)) //
macro gradE12 (u1,u2,l1,l2) (0.5*(dx(u1)*dy(l1) + dx(u2)*dy(l2) + dy(u1)*dx(l1) + dy(u2)*dx(l2) + dy(l1) + dx(l2))) //
macro gradE21 (u1,u2,l1,l2) (0.5*(dx(u1)*dy(l1) + dx(u2)*dy(l2) + dy(u1)*dx(l1) + dy(u2)*dx(l2) + dy(l1) + dx(l2))) //
macro gradE22 (u1,u2,l1,l2) (dy(u1)*dy(l1) + dy(u2)*dy(l2) + dy(l2)) //

//d^2 Eij(u1,u2)/du^2*lambda * [phi1,phi2] (this is the test function)
macro grad2E11 (phi1,phi2,l1,l2) (gradE11(phi1,phi2,l1,l2)) //
macro grad2E12 (phi1,phi2,l1,l2) (gradE12(phi1,phi2,l1,l2)) //
macro grad2E21 (phi1,phi2,l1,l2) (gradE21(phi1,phi2,l1,l2)) //
macro grad2E22 (phi1,phi2,l1,l2) (gradE22(phi1,phi2,l1,l2)) //

// Helmholtz filter
problem helmholtz(vH, psi) = int2d(Th)( radius*(dx(vH)*dx(psi) + dy(vH)*dy(psi)) )
                           + int2d(Th)( vH*psi )
                           - int2d(Th)( v *psi );

// Functional = 1/2 * (delta Target)^2
func real J(real[int] & v)
{
  Vhp w;
  w[] = v;
  plot(w, fill = 1, value = 1, cmm = "j = "+jj+" ii = "+ii);

  cout << "Solving primal problems..." << endl;

  solve primal([u1,u2], [psi1, psi2]) =
		int2d(Th) (L*detF(u1,u2)*(detF(u1,u2)-1.) * (C11(u1,u2) * gradE11(u1,u2,psi1,psi2)
		                                             + C12(u1,u2) * gradE12(u1,u2,psi1,psi2)
																								 + C21(u1,u2) * gradE21(u1,u2,psi1,psi2)
																								 + C22(u1,u2) * gradE22(u1,u2,psi1,psi2))
							 + 2.0 * M * (E11(u1,u2) * gradE11(u1,u2,psi1,psi2) + E12(u1,u2) * gradE12(u1,u2,psi1,psi2)
							            + E21(u1,u2) * gradE21(u1,u2,psi1,psi2) + E22(u1,u2) * gradE22(u1,u2,psi1,psi2)))
		// - (rhs = 0.0)
		// B.C. boh ...;

		//here need to define properly J


  jj = jj + 1;
  return 1;
}

// Gradient of the functional (approccio lagrangiano)
func real[int] gradJ(real[int] & v)
{
  Vhp w;
  w[] = v;
  real [int] dJ(Vhp.ndof);

  cout << "Solving dual problems..." << endl;

	solve dual([l1,l2], [phi1, phi2]) =
		int2d(Th) (L* (2.0*detF(u1,u2)-1.) * (dx(phi1)*F22(u1,u2) + dy(phi2)*F11(u1,u2) - dy(phi1)*F21(u1,u2) - dx(phi2)*F12(u1,u2))
		                                    * (invC11(u1,u2) * gradE11(u1,u2,l1,l2) + invC12(u1,u2) * gradE12(u1,u2,l1,l2)
								                        + invC21(u1,u2) * gradE21(u1,u2,l1,l2) + invC22(u1,u2) * gradE22(u1,u2,l1,l2))
						 + L* (detF(u1,u2)-1) * detF(u1,u2) * ( - D1111(u1,u2) * gradE11(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2) //following 2nd hyp
						                                          - D1112(u1,u2) * gradE12(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2)
																											- D1121(u1,u2) * gradE21(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2)
																											- D1122(u1,u2) * gradE22(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2)
																											- D1211(u1,u2) * gradE11(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2)
																											- D1212(u1,u2) * gradE12(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2)
																											- D1221(u1,u2) * gradE21(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2)
																											- D1222(u1,u2) * gradE22(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2)
																											- D2111(u1,u2) * gradE11(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2)
																											- D2112(u1,u2) * gradE12(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2)
																											- D2121(u1,u2) * gradE21(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2)
																											- D2122(u1,u2) * gradE22(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2)
																											- D2211(u1,u2) * gradE11(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2)
																											- D2212(u1,u2) * gradE12(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2)
																											- D2221(u1,u2) * gradE21(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2)
																											- D2222(u1,u2) * gradE22(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2))
						+ 2.0*M* (gradE11(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2) + E11(u1,u2) * grad2E11(phi1,phi2,l1,l2)
						          gradE12(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2) + E12(u1,u2) * grad2E12(phi1,phi2,l1,l2)
											gradE21(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2) + E21(u1,u2) * grad2E21(phi1,phi2,l1,l2)
											gradE22(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2) + E22(u1,u2) * grad2E22(phi1,phi2,l1,l2))
							)
			// - rhs  (missing ~ related to J)
			// B.C. ?
    ;
	/*
  varf gradient(SS, psi) = depends on choice of J


	*/

  // dJ = gradient(0, Vhp);
  return 1; //dJ;
}

// Constraint: volume fraction
func real C(real[int] & v)
{
  Vhp w;
  w[] = v;

  real fraction = int2d(Th)(w);

  return fraction;
}

func real[int] ipC(real[int] & v)
{
  real[int] cc = [C(v)];
  return cc;
}

// Constraint gradient
func real[int] dC(real[int] & v)
{
  Vhp w;
  w[] = v;

  varf dc(u,uu)   = int2d(Th)(uu);

  real [int] jacC = dc(0,Vhp);
  return jacC;
}

matrix mdC;

func matrix ipGradC(real[int] & v)
{
  real[int,int] dc(1,Vhp.ndof);
  dc(0,:) = dC(v);

  mdC = dc;
  return mdC;
}

// Variabili per ottimizzatore
int[int] gvi(Vhp.ndof), gvj = 0:Vhp.ndof-1;
gvi = 0;

Vhp xlb = 1e-4, xub = 1;    // lower and upper bounds for v

real tolv = 0.;

real[int] clb = [0*vf*Volume], cub = [vf*Volume]; // lower and upper bounds for constraint

real tolmesh = 0.0001;
real stopmesh = tolmesh + 1.;
int ntold = Th.nt;
int maxit = 21;

v = abs(sin(2*pi*x*0.25)*sin(2*pi*y*0.5));
//v = abs(sin(0.5*pi*x)*sin(1*pi*y));

real tau = .00001;
real maxsK;
include "makemetrica.edp";

while(stopmesh > tolmesh && ii < maxit){

	jj = 0;

	// Ottimizzatore
	IPOPT(J, gradJ, ipC, ipGradC, v[],
	  lb  = xlb[], ub  = xub[],
   	  clb = clb  , cub = cub  ,
	  checkindex = 1, structjacc = [gvi,gvj],
      maxiter = 35*(ii<=3) + 10*(ii>3), warmstart = ii,
	  lm = lm, uz = uz[], lz = lz[]
	  //tol=1e-5,
	  //printlevel = 1,
	  //derivativetest="first-order");
      //,maxiter=10);
	  );

	// Attivazione filtraggio Helmholtz
	if(ii <=-2){
	helmholtz;
	plot(v,  wait = 1, fill = 1, cmm = "phase field after IPOPT");
	plot(vH, wait = 1, fill = 1, cmm = "filtered phase field");

	v = vH;
	}

	maxsK = 1;
	ntold = Th.nt;

	// Calcolo metrica e adattazione di mesh (periodica)
	makemetrica(tau);
	Th = adaptmesh(Th, metric = [m11[],m12[],m22[]], nbvx = 12000, periodic=[[2,y],[4,y],[1,x],[3,x]]);  //ANISO
	//plot(Th, wait = 1);
	cout << "maxsK = " << maxsK << endl;

	// Attivazione filtraggio Heaviside
	if((ii >= 5 && ii <= 6) || ii == 19){
		real beta = 10*(ii < 19) + 7*(ii == 19);
		v = 0.5 + tanh(beta*(v-0.5))/(2*tanh(0.5*beta));
	}

	// Proiezione variabili su nuova mesh
	v = v;
	xlb = xlb;
	xub = xub;
	gvi = gvi;
	gvj = 0:Vhp.ndof-1;
	lz = lz;
	uz = uz;
	m11 = m11;
	m12 = m12;
	m22 = m22;

	stopmesh = abs(Th.nt - real(ntold))/ntold;
	ii += 1;
	cout << "Iterazione " << ii << ", Errore mesh = " << stopmesh << endl;

	savevtk("sol_toll"+tau+"_vf"+vf+"iter"+(ii-1)+".vtk", Th, v, dataname="Density", order=ffordervel);

}

cout << Th.nt << endl;

plot(v,  wait = 1, fill = 1, cmm = "phase field after IPOPT, FINAL");
plot(vH, wait = 1, fill = 1, cmm = "filtered phase field, FINAL");
