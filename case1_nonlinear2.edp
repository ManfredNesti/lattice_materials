load "ff-Ipopt";
load "ffrandom";
load "iovtk";
//verbosity = 1;

ofstream out1("residual_newton.csv", append); //file per residui Newton

// Vettore per il salvataggio delle immagini in formato vtk (da usare in Paraview)
int[int] ffordervel = [1];
int ii = 0;

int jj = 0;
int n = 30;
mesh Th = square(n, n, [x, y]);

// Spazi funzionali (periodici e non) (BC???)
//density space
fespace Xh1(Th,P1);
fespace Xhp(Th, P1, periodic = [[2,y],[4,y],[1,x],[3,x]]);
Xhp v,vH, w, psi, lz, uz; //density, filtered density, test density, param for ipopt
Xh1 m11,m12,m22;

//displacement space
fespace Vh(Th, [P1, P1]);
Vh [u1,u2], [u10,u20], [psi1,psi2], [varu1,varu2], [err1,err2], //displacement, du, test displacement
   [l1, l2], [phi1, phi2]; //lambda e lambda test

fespace Xh0(Th, P0); //  periodic = [[2,y],[4,y],[1,x],[3,x]]);
Xh0 vol = area;

//verbosity = 0.;

//v = abs(sin(2*pi*x*0.25)*sin(2*pi*y*0.5));
//v = 1;
//v = (x<=0.5)*(y>=0.5)*(y<=0.7);
//v = 5*abs((x-0.5)^2 + (y-0.5)^2 + 0.^8);
//plot(v, fill = 1);


srandom(10);
for(int ii = 0; ii < Xhp.ndof; ii++)
	v[][ii] = random()/3e9;

real [int] lm(1); //param for ipopt

// Varibiali ausiliarie
real q = 4.;
real radius = 1./50^2;
real Omega = int2d(Th)(1.);
real weigth = 0.;

// Coefficients
real nu = 0.3;
real E = 1.;
real L = E*nu/(1-nu^2); //E*nu/(1+nu)/(1-2*nu); HO TENUTO QUELLO SBAGLIATO
real M = E/(2*(1+nu));
real nu12;
real d1 = 1.; //u traction given

real Volume = int2d(Th)(1.);

// Volume fraction e valore target
real vf = 0.3;
real nutarget = 0.3;

// Macro
//Gradient of a vector field (u1, u2)
macro grad11(u1, u2) (dx(u1)) //
macro grad12(u1, u2) (dy(u1)) //
macro grad21(u1, u2) (dx(u2)) //
macro grad22(u1, u2) (dy(u2)) //

//Deformation gradient F
macro F11(u1,u2) (1.0 + grad11(u1,u2)) //
macro F12(u1,u2) (0.0 + grad12(u1,u2)) //
macro F21(u1,u2) (0.0 + grad21(u1,u2)) //
macro F22(u1,u2) (1.0 + grad22(u1,u2)) //

// Components Green-Lagrange strain tensor E
macro E11(u1,u2) 0.5*(grad11(u1,u2)*grad11(u1,u2) + 2.*grad11(u1,u2) + grad21(u1,u2)*grad21(u1,u2)) //
macro E12(u1,u2) 0.5*(grad11(u1,u2)*grad12(u1,u2) + grad21(u1,u2)*grad22(u1,u2) + grad12(u1,u2) + grad21(u1,u2)) //
macro E21(u1,u2) 0.5*(grad11(u1,u2)*grad12(u1,u2) + grad21(u1,u2)*grad22(u1,u2) + grad12(u1,u2) + grad21(u1,u2)) //
macro E22(u1,u2) 0.5*(grad12(u1,u2)*grad12(u1,u2) + 2.*grad22(u1,u2) + grad22(u1,u2)*grad22(u1,u2)) //

macro traceE(u1,u2)	(E11(u1,u2) + E22(u1,u2)) // Trace of Green-Lagrange tensor

macro detF(u1,u2) (F11(u1,u2) * F22(u1,u2) - F12(u1,u2) * F21(u1,u2) )  //J determinant of F

//Right Cauchy-Green deformation tensor C
macro C11(u1,u2) (2*E11(u1,u2) + 1.0) //
macro C12(u1,u2) (2*E12(u1,u2)) //
macro C21(u1,u2) (2*E21(u1,u2)) //
macro C22(u1,u2) (2*E22(u1,u2) + 1.0) //

macro detC(u1,u2) (C11(u1,u2) * C22(u1,u2) - C12(u1,u2) * C21(u1,u2)) // determinantof C

//Inverse of C: C^-1 (symmetric)
macro invC11(u1,u2) (1/detC(u1,u2) * (C22(u1,u2))) //
macro invC12(u1,u2) (1/detC(u1,u2) * ((-1)* C12(u1,u2))) //
macro invC21(u1,u2) (1/detC(u1,u2) * ((-1)* C21(u1,u2))) //
macro invC22(u1,u2) (1/detC(u1,u2) * (C11(u1,u2))) //

// Second Piola-Kirchhoff stress tensor for Phi4 Sij forse non serve ...

// Dijkl = - d(Cij^-1)/dEkl !!! verificata abbastanza ... anche il meno
macro D1111(u1,u2) (invC11(u1,u2)*invC11(u1,u2) * 2 ) //
macro D1211(u1,u2) (invC11(u1,u2)*invC21(u1,u2) * 2 ) // = D1121, D1112, D2111 for symmetry of C,invC and E
macro D1121(u1,u2) (invC11(u1,u2)*invC12(u1,u2) * 2 ) //
macro D1112(u1,u2) (invC11(u1,u2)*invC12(u1,u2) * 2 ) //
macro D2111(u1,u2) (invC11(u1,u2)*invC21(u1,u2) * 2 ) //
macro D1122(u1,u2) (invC12(u1,u2)*invC12(u1,u2) * 2 ) // = D2211
macro D2211(u1,u2) (invC21(u1,u2)*invC21(u1,u2) * 2 ) //
macro D1212(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) // = D2121, D1221, D2112
macro D2121(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D1221(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D2112(u1,u2) (invC11(u1,u2)*invC22(u1,u2) + invC12(u1,u2)*invC21(u1,u2)) //
macro D2122(u1,u2) (invC22(u1,u2)*invC12(u1,u2) * 2 ) // = D2212, D2221, D1222
macro D2212(u1,u2) (invC22(u1,u2)*invC21(u1,u2) * 2 ) //
macro D2221(u1,u2) (invC22(u1,u2)*invC21(u1,u2) * 2 ) //
macro D1222(u1,u2) (invC22(u1,u2)*invC12(u1,u2) * 2 ) //
macro D2222(u1,u2) (invC22(u1,u2)*invC22(u1,u2) * 2 ) //

//dEij(u1,u2)/du * lambda (l'ho corretto: CI ERAVAMO PERSI UN *0.5 PER STRADA?)
macro gradE11 (u1,u2,l1,l2) (grad11(u1,u2)*grad11(l1,l2) + grad21(u1,u2)*grad21(l1,l2) + grad11(l1,l2)) //
macro gradE12 (u1,u2,l1,l2) (0.5*(grad11(u1,u2)*grad12(l1,l2) + grad21(u1,u2)*grad22(l1,l2) + grad12(u1,u2)*grad11(l1,l2) + grad22(u1,u2)*grad21(l1,l2) + grad12(l1,l2) + grad21(l1,l2)) )// vanno aggiunti dopo come termine noto
macro gradE21 (u1,u2,l1,l2) (0.5*(grad11(u1,u2)*grad12(l1,l2) + grad21(u1,u2)*grad22(l1,l2) + grad12(u1,u2)*grad11(l1,l2) + grad22(u1,u2)*grad21(l1,l2) + grad12(l1,l2) + grad21(l1,l2)) )  // vanno aggiunti dopo come termine noto
macro gradE22 (u1,u2,l1,l2) (grad12(u1,u2)*grad12(l1,l2) + grad22(u1,u2)*grad22(l1,l2) + grad22(l1,l2)) //

//d^2 Eij(u1,u2)/du^2*lambda * [phi1,phi2] (this is the test function)
macro grad2E11 (phi1,phi2,l1,l2) (grad11(phi1,phi2)*grad11(l1,l2) + grad21(phi1,phi2)*grad21(l1,l2)) //
macro grad2E12 (phi1,phi2,l1,l2) (0.5*(grad11(phi1,phi2)*grad12(l1,l2) + grad21(phi1,phi2)*grad22(l1,l2) + grad12(phi1,phi2)*grad11(l1,l2) + grad22(phi1,phi2)*grad21(l1,l2))) //
macro grad2E21 (phi1,phi2,l1,l2) (0.5*(grad11(phi1,phi2)*grad12(l1,l2) + grad21(phi1,phi2)*grad22(l1,l2) + grad12(phi1,phi2)*grad11(l1,l2) + grad22(phi1,phi2)*grad21(l1,l2))) //
macro grad2E22 (phi1,phi2,l1,l2) (grad12(phi1,phi2)*grad12(l1,l2) + grad22(phi1,phi2)*grad22(l1,l2)) //

// Helmholtz filter
problem helmholtz(vH, psi) = int2d(Th)( radius*(dx(vH)*dx(psi) + dy(vH)*dy(psi)) )
                           + int2d(Th)( vH*psi )
                           - int2d(Th)( v *psi );

 // residual Newton method
 func real errorL2()
 {
   // store increments
   err1[] = u1[];
   err1[] -= u10[];

   real erru = int2d(Th)(err1^2 + err2^2);
   real normu = int2d(Th)(u10^2 + u20^2);
   // return error estimate (stopping criterion)
   return sqrt(erru / (normu+1e-15));

}
//Newton method for primal
problem primallinearized([varu1,varu2], [psi1, psi2]) =
  int2d(Th) (w^q * L * (2.0*detF(u10,u20)-1.) * (dx(psi1)*F22(u10,u20) + dy(psi2)*F11(u10,u20) - dy(psi1)*F21(u10,u20) - dx(psi2)*F12(u10,u20))
                                        * (invC11(u10,u20) * gradE11(u10,u20,varu1,varu2) + invC12(u10,u20) * gradE12(u10,u20,varu1,varu2)
                                        +  invC21(u10,u20) * gradE21(u10,u20,varu1,varu2) + invC22(u10,u20) * gradE22(u10,u20,varu1,varu2))

           + w^q * L * (detF(u10,u20)-1) * detF(u10,u20) * ( - D1111(u10,u20) * gradE11(u10,u20,psi1,psi2) * gradE11(u10,u20,varu1,varu2)
                                                       - D1112(u10,u20) * gradE12(u10,u20,psi1,psi2) * gradE11(u10,u20,varu1,varu2)
                                                       - D1121(u10,u20) * gradE21(u10,u20,psi1,psi2) * gradE11(u10,u20,varu1,varu2)
                                                       - D1122(u10,u20) * gradE22(u10,u20,psi1,psi2) * gradE11(u10,u20,varu1,varu2) + invC11(u10,u20) * grad2E11(psi1,psi2,varu1,varu2)
                                                       - D1211(u10,u20) * gradE11(u10,u20,psi1,psi2) * gradE12(u10,u20,varu1,varu2)
                                                       - D1212(u10,u20) * gradE12(u10,u20,psi1,psi2) * gradE12(u10,u20,varu1,varu2)
                                                       - D1221(u10,u20) * gradE21(u10,u20,psi1,psi2) * gradE12(u10,u20,varu1,varu2)
                                                       - D1222(u10,u20) * gradE22(u10,u20,psi1,psi2) * gradE12(u10,u20,varu1,varu2) + invC12(u10,u20) * grad2E12(psi1,psi2,varu1,varu2)
                                                       - D2111(u10,u20) * gradE11(u10,u20,psi1,psi2) * gradE21(u10,u20,varu1,varu2)
                                                       - D2112(u10,u20) * gradE12(u10,u20,psi1,psi2) * gradE21(u10,u20,varu1,varu2)
                                                       - D2121(u10,u20) * gradE21(u10,u20,psi1,psi2) * gradE21(u10,u20,varu1,varu2)
                                                       - D2122(u10,u20) * gradE22(u10,u20,psi1,psi2) * gradE21(u10,u20,varu1,varu2) + invC21(u10,u20) * grad2E21(psi1,psi2,varu1,varu2)
                                                       - D2211(u10,u20) * gradE11(u10,u20,psi1,psi2) * gradE22(u10,u20,varu1,varu2)
                                                       - D2212(u10,u20) * gradE12(u10,u20,psi1,psi2) * gradE22(u10,u20,varu1,varu2)
                                                       - D2221(u10,u20) * gradE21(u10,u20,psi1,psi2) * gradE22(u10,u20,varu1,varu2)
                                                       - D2222(u10,u20) * gradE22(u10,u20,psi1,psi2) * gradE22(u10,u20,varu1,varu2) + invC22(u10,u20) * grad2E22(psi1,psi2,varu1,varu2)
                                                   )

            + w^q * 2.0*M* (gradE11(u10,u20,psi1,psi2) * gradE11(u10,u20,varu1,varu2) + E11(u10,u20) * grad2E11(psi1,psi2,varu1,varu2) +
			                      gradE12(u10,u20,psi1,psi2) * gradE12(u10,u20,varu1,varu2) + E12(u10,u20) * grad2E12(psi1,psi2,varu1,varu2) +
			                      gradE21(u10,u20,psi1,psi2) * gradE21(u10,u20,varu1,varu2) + E21(u10,u20) * grad2E21(psi1,psi2,varu1,varu2) +
			                      gradE22(u10,u20,psi1,psi2) * gradE22(u10,u20,varu1,varu2) + E22(u10,u20) * grad2E22(psi1,psi2,varu1,varu2) )
           )

    + int2d(Th) (w^q * L*detF(u10,u20)*(detF(u10,u20)-1.) * (invC11(u10,u20) * gradE11(u10,u20,psi1,psi2)
			                                                     + invC12(u10,u20) * gradE12(u10,u20,psi1,psi2)
			          																					 + invC21(u10,u20) * gradE21(u10,u20,psi1,psi2)
			          																					 + invC22(u10,u20) * gradE22(u10,u20,psi1,psi2))
     				    + w^q * 2.0 * M * (E11(u10,u20) * gradE11(u10,u20,psi1,psi2)
			                           + E12(u10,u20) * gradE12(u10,u20,psi1,psi2)
			    				               + E21(u10,u20) * gradE21(u10,u20,psi1,psi2)
			                           + E22(u10,u20) * gradE22(u10,u20,psi1,psi2)))
    + on(2,varu1=0) // dirichlet
    + on(1,varu2=0) // symmetric bc
    + on(4,varu1=0) // symmetric bc
  ;

// Functional = 1/2 * (delta Target)^2
func real J(real[int] & v)
{
  Xhp w; //density
  w[] = v;
  plot(w, fill = 1, value = 1, cmm = "j = "+jj+" ii = "+ii);

  cout << "Solving primal problems..." << endl;

	//Initialization:
	[u10, u20] = [d1*x, 0]; //u_k old che soddisfa BC Dirichlet
	[u1, u2] = [u10, u20]; // u_1
	real tol = 1.e-3;
	real res = 2. * tol;
	int loopcount = 0;
	int loopmax = 100;
	real alpha = 1.0;

	// Iterations
	while (loopcount <= loopmax && res >= tol){
	    loopcount ++;
	    cout << "Loop " << loopcount << endl;

	    // Solve
	    primallinearized;
	    // Update
	    u1[] += alpha * varu1[];// u_k+1 = u_k + delta_u (- se trovassimo - delta u)
	    // update err for the stopping criterion
	    res = errorL2();

	    cout << " L^2 residual = " << res << endl;
	    out1 << res ;
	    out1 << endl;
	    //Update old solution
	    u10[] = u1[];

	    // Plot
	    plot([u1,u2], cmm="displacement");
	}

	real d2 = int1d(Th,3)(w^q * u2);
	nu12 = - d2 / d1; //estimated nu

  cout << "*********************************************" << endl;
  cout << "j = " << jj << endl;
  cout << "Poisson's ratio = " << nu12 << endl;

  jj = jj + 1;

	return 0.5 * (nu12 - nutarget)^2;
}

// Gradient of the functional (approccio lagrangiano)
func real[int] gradJ(real[int] & v)
{
  Xhp w;
  w[] = v;
  real [int] dJ(Xhp.ndof);
	real Curly = (nu12 - nutarget) / d1 ;

  cout << "Solving dual problems..." << endl;

	solve dual([l1,l2], [phi1, phi2]) =
	int2d(Th) (w^q* L * (2.0*detF(u1,u2)-1.) * (dx(phi1)*F22(u1,u2) + dy(phi2)*F11(u1,u2) - dy(phi1)*F21(u1,u2) - dx(phi2)*F12(u1,u2))
                                        * (invC11(u1,u2) * gradE11(u1,u2,l1,l2) + invC12(u1,u2) * gradE12(u1,u2,l1,l2)
                                        +  invC21(u1,u2) * gradE21(u1,u2,l1,l2) + invC22(u1,u2) * gradE22(u1,u2,l1,l2))

           + w^q* L * (detF(u1,u2)-1) * detF(u1,u2) * (  - D1111(u1,u2) * gradE11(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2)
			                                                   - D1112(u1,u2) * gradE12(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2)
			                                                   - D1121(u1,u2) * gradE21(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2)
			                                                   - D1122(u1,u2) * gradE22(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2) + invC11(u1,u2) * grad2E11(phi1,phi2,l1,l2)
			                                                   - D1211(u1,u2) * gradE11(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2)
			                                                   - D1212(u1,u2) * gradE12(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2)
			                                                   - D1221(u1,u2) * gradE21(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2)
			                                                   - D1222(u1,u2) * gradE22(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2) + invC12(u1,u2) * grad2E12(phi1,phi2,l1,l2)
			                                                   - D2111(u1,u2) * gradE11(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2)
			                                                   - D2112(u1,u2) * gradE12(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2)
			                                                   - D2121(u1,u2) * gradE21(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2)
			                                                   - D2122(u1,u2) * gradE22(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2) + invC21(u1,u2) * grad2E21(phi1,phi2,l1,l2)
			                                                   - D2211(u1,u2) * gradE11(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2)
			                                                   - D2212(u1,u2) * gradE12(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2)
			                                                   - D2221(u1,u2) * gradE21(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2)
			                                                   - D2222(u1,u2) * gradE22(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2) + invC22(u1,u2) * grad2E22(phi1,phi2,l1,l2)
	                                                    )

            + w^q* 2.0*M* (gradE11(u1,u2,phi1,phi2) * gradE11(u1,u2,l1,l2) + E11(u1,u2) * grad2E11(phi1,phi2,l1,l2) +
                      gradE12(u1,u2,phi1,phi2) * gradE12(u1,u2,l1,l2) + E12(u1,u2) * grad2E12(phi1,phi2,l1,l2) +
                      gradE21(u1,u2,phi1,phi2) * gradE21(u1,u2,l1,l2) + E21(u1,u2) * grad2E21(phi1,phi2,l1,l2) +
                      gradE22(u1,u2,phi1,phi2) * gradE22(u1,u2,l1,l2) + E22(u1,u2) * grad2E22(phi1,phi2,l1,l2) )
           )
					 +  int1d(Th,3)(Curly * phi2)
					 + on(2,l1=0) //dirichlet
			     + on(1,l2=0) // symmetric bc
			     + on(4,l1=0) // symmetric bc
			   ;

  varf gradient(SS, psi) =
      int2d(Th) (q*w^(q-1)*psi*  L*detF(u1,u2)*(detF(u1,u2)-1.) * (invC11(u1,u2) * gradE11(u1,u2,l1,l2)
          			                                                     + invC12(u1,u2) * gradE12(u1,u2,l1,l2)
          			          																					 + invC21(u1,u2) * gradE21(u1,u2,l1,l2)
          			          																					 + invC22(u1,u2) * gradE22(u1,u2,l1,l2))
       				 + q*w^(q-1)*psi* 2.0 * M * (E11(u1,u2) * gradE11(u1,u2,l1,l2)
        			                           + E12(u1,u2) * gradE12(u1,u2,l1,l2)
        			    				               + E21(u1,u2) * gradE21(u1,u2,l1,l2)
        			                           + E22(u1,u2) * gradE22(u1,u2,l1,l2)))
      /*- int1d(Th,3) (q*w^(q-1)*psi* u2 * Curly)*/;

  dJ = gradient(0, Xhp);
  return dJ;
}

// Constraint: volume fraction
func real C(real[int] & v)
{
  Xhp w;
  w[] = v;

  real fraction = int2d(Th)(w);

  return fraction;
}

func real[int] ipC(real[int] & v)
{
  real[int] cc = [C(v)];
  return cc;
}

// Constraint gradient
func real[int] dC(real[int] & v)
{
  Xhp w;
  w[] = v;

  varf dc(u,uu)   = int2d(Th)(uu);

  real [int] jacC = dc(0,Xhp);
  return jacC;
}

matrix mdC;

func matrix ipGradC(real[int] & v)
{
  real[int,int] dc(1,Xhp.ndof);
  dc(0,:) = dC(v);

  mdC = dc;
  return mdC;
}

// Variabili per ottimizzatore
int[int] gvi(Xhp.ndof), gvj = 0:Xhp.ndof-1;
gvi = 0;

Xhp xlb = 1e-4, xub = 1;    // lower and upper bounds for v density

real tolv = 0.;

real[int] clb = [0*vf*Volume], cub = [vf*Volume]; // lower and upper bounds for constraint

real tolmesh = 0.0001;
real stopmesh = tolmesh + 1.;
int ntold = Th.nt;
int maxit = 21;

v = abs(sin(2*pi*x*0.25)*sin(2*pi*y*0.5));
//v = abs(sin(0.5*pi*x)*sin(1*pi*y));

real tau = .00001;
real maxsK;
include "makemetrica.edp";

while(stopmesh > tolmesh && ii < maxit){

	jj = 0;

	// Ottimizzatore
	IPOPT(J, gradJ, ipC, ipGradC, v[],
	  lb  = xlb[], ub  = xub[],
   	  clb = clb  , cub = cub  ,
	  checkindex = 1, structjacc = [gvi,gvj],
      maxiter = 35*(ii<=3) + 10*(ii>3), warmstart = ii,
	  lm = lm, uz = uz[], lz = lz[]
	  //tol=1e-5,
	  //printlevel = 1,
	  //derivativetest="first-order");
      //,maxiter=10);
	  );

	// Attivazione filtraggio Helmholtz
	if(ii <=-2){ //poco chiaro quando filtri con Helmholtz ... direi mai
	helmholtz;
	plot(v,  wait = 1, fill = 1, cmm = "phase field after IPOPT");
	plot(vH, wait = 1, fill = 1, cmm = "filtered phase field");

	v = vH;
	}

	maxsK = 1;
	ntold = Th.nt;

	// Calcolo metrica e adattazione di mesh (periodica)
	makemetrica(tau);
	Th = adaptmesh(Th, metric = [m11[],m12[],m22[]], nbvx = 12000, periodic=[[2,y],[4,y],[1,x],[3,x]]);  //ANISO
	//plot(Th, wait = 1);
	cout << "maxsK = " << maxsK << endl;

	// Attivazione filtraggio Heaviside
	if((ii >= 5 && ii <= 6) || ii == 19){
		real beta = 10*(ii < 19) + 7*(ii == 19);
		v = 0.5 + tanh(beta*(v-0.5))/(2*tanh(0.5*beta));
	}

	// Proiezione variabili su nuova mesh
	v = v;
	xlb = xlb;
	xub = xub;
	gvi = gvi;
	gvj = 0:Xhp.ndof-1;
	lz = lz;
	uz = uz;
	m11 = m11;
	m12 = m12;
	m22 = m22;

	stopmesh = abs(Th.nt - real(ntold))/ntold;
	ii += 1;
	cout << "Iterazione " << ii << ", Errore mesh = " << stopmesh << endl;

	savevtk("sol_toll"+tau+"_vf"+vf+"iter"+(ii-1)+".vtk", Th, v, dataname="Density", order=ffordervel);

}

cout << Th.nt << endl;

plot(v,  wait = 1, fill = 1, cmm = "phase field after IPOPT, FINAL");
plot(vH, wait = 1, fill = 1, cmm = "filtered phase field, FINAL");
